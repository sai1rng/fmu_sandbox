import json
from pathlib import Path
import importlib.resources
import os
import sys

from fmpy import read_model_description, extract
from fmpy.fmi2 import FMU2Slave as FMPY_FMU2Slave

from pythonfmu.fmi2slave import Fmi2Slave, Fmi2Causality, Fmi2Variability, Fmi2Initial
from pythonfmu.variables import Real, Integer, Boolean, String

# Mapping from FMPy types to PythonFMU types for variable registration
FMPY_TO_PYTHONFMU_VAR_TYPE = {
    "Real": Real,
    "Integer": Integer,
    "Boolean": Boolean,
    "String": String,
}

class FMUWrapper(Fmi2Slave):
    """
    This Python script is compiled into a self-contained wrapper FMU.
    It packages the original FMU and a fault configuration file in its
    resources, exposing an identical interface to the simulation master.
    """
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.current_time = 0.0
        self.active_faults = {}
        self.original_fmu_instance = None
        self.original_fmu_unzip_dir = None
        self.value_references = {} # To store VRs of registered variables

        # --- 1. Locate and load resources packaged inside this FMU ---
        # --- FIX FOR TypeError: 'wrapper_slave' is not a package ---
        # The pythonfmu build tool runs this script in an isolated environment
        # where importlib.resources cannot find the files. A more robust
        # method is to find the resources relative to this script's path.
        # The `resources` kwarg is passed by the pythonfmu tool.
        resources_path = Path(kwargs.get("resources"))
        
        # UPDATED: Assumes the FMU to be wrapped is named 'Amplifier.fmu'
        original_fmu_path = resources_path / "Amplifier.fmu"
        config_path = resources_path / "fault_config.json"

        # --- 2. Load fault configuration ---
        with open(config_path, 'r') as f:
            self.fault_config = json.load(f)

        # --- 3. Dynamically mirror the original FMU's interface ---
        self.model_description = read_model_description(original_fmu_path)
        
        self.modelName = f"{self.model_description.modelName}_FaultWrapper"
        self.author = "Wrapper generated by FMU Fault Injection Framework"
        self.description = f"Wraps the '{self.model_description.modelName}' FMU to inject faults."

        for var in self.model_description.modelVariables:
            var_type_class = FMPY_TO_PYTHONFMU_VAR_TYPE.get(var.type, Real)
            self.register_variable(
                var_type_class(
                    name=var.name,
                    causality=Fmi2Causality[var.causality],
                    variability=Fmi2Variability[var.variability],
                    initial=Fmi2Initial[var.initial] if var.initial else Fmi2Initial.undefined,
                    start=var.start
                )
            )
            self.value_references[var.name] = var.valueReference

            start_value = var.start
            if start_value is None:
                if var.type == "Real": start_value = 0.0
                elif var.type == "Integer": start_value = 0
                elif var.type == "Boolean": start_value = False
                elif var.type == "String": start_value = ""
            setattr(self, var.name, start_value)

        # --- 4. Prepare the original FMU for internal simulation ---
        self.original_fmu_unzip_dir = extract(original_fmu_path)
        self.original_fmu_instance = FMPY_FMU2Slave(
            guid=self.model_description.guid,
            unzipDirectory=self.original_fmu_unzip_dir,
            modelIdentifier=self.model_description.coSimulation.modelIdentifier,
            instanceName='wrapped_instance',
            fmiCallLogger=None
        )

    def set_real(self, vrs, values):
        super().set_real(vrs, values)
        for vr, value in zip(vrs, values):
            var_name = self._get_name_by_vr(vr)
            if self.vars[var_name].causality == Fmi2Causality.input:
                 self._set_value(var_name, value)
    
    def set_integer(self, vrs, values):
        super().set_integer(vrs, values)
        for vr, value in zip(vrs, values):
            var_name = self._get_name_by_vr(vr)
            if self.vars[var_name].causality == Fmi2Causality.input:
                self._set_value(var_name, value)

    def set_boolean(self, vrs, values):
        super().set_boolean(vrs, values)
        for vr, value in zip(vrs, values):
            var_name = self._get_name_by_vr(vr)
            if self.vars[var_name].causality == Fmi2Causality.input:
                self._set_value(var_name, value)

    def set_string(self, vrs, values):
        super().set_string(vrs, values)
        for vr, value in zip(vrs, values):
            var_name = self._get_name_by_vr(vr)
            if self.vars[var_name].causality == Fmi2Causality.input:
                self._set_value(var_name, value)

    def setup_experiment(self, start_time, stop_time=None, tolerance=None):
        self.current_time = start_time
        self.original_fmu_instance.setupExperiment(
            startTime=start_time, stopTime=stop_time, tolerance=tolerance
        )

    def enter_initialization_mode(self):
        self.original_fmu_instance.enterInitializationMode()

    def exit_initialization_mode(self):
        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.parameter or var.variability == Fmi2Variability.fixed:
                 self._set_value(name, getattr(self, name))
        
        self.original_fmu_instance.exitInitializationMode()

    def do_step(self, current_time, step_size):
        self.current_time = current_time
        self._update_active_faults()
        
        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.input:
                self._set_value(name, getattr(self, name))

        self.original_fmu_instance.doStep(
            currentCommunicationPoint=current_time,
            communicationStepSize=step_size,
            noSetFMUStatePriorToCurrentPoint=True
        )

        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.output:
                value = self._get_value(name)
                if value is not None:
                    setattr(self, name, value[0])

        return True

    def reset(self):
        self.original_fmu_instance.reset()

    def terminate(self):
        self.original_fmu_instance.terminate()
        self.original_fmu_instance.freeInstance()

    def _get_value(self, var_name):
        vr = self.value_references[var_name]
        var_type = self.vars[var_name].type.__name__
        
        if var_type == 'Real':
            return self.original_fmu_instance.getReal([vr])
        return None

    def _set_value(self, var_name, value):
        vr = self.value_references[var_name]
        var_type = self.vars[var_name].type.__name__
        
        modified_value = value
        
        if vr in self.active_faults:
            fault = self.active_faults[vr]
            fault_type = fault['type']
            
            if fault_type == 'stuckAtValue':
                modified_value = fault['value']
            elif fault_type == 'offset':
                modified_value = value + fault['value']
            
            if modified_value != value:
                print(f"--- FAULT INJECTED at t={self.current_time:.2f}s on '{var_name}' (vr={vr}) ---")
                print(f"  Original: {value}, Faulty: {modified_value} (Type: {fault_type})")

        if var_type == 'Real':
            self.original_fmu_instance.setReal([vr], [modified_value])

    def _update_active_faults(self):
        self.active_faults = {}
        for event in self.fault_config.get('events', []):
            start_time = event.get('startTime', 0)
            duration = event.get('duration', float('inf'))
            end_time = start_time + duration
            
            if start_time <= self.current_time < end_time:
                for var_fault in event.get('variables', []):
                    vr = var_fault.get('valueReference')
                    if vr is not None:
                        self.active_faults[vr] = {
                            'type': var_fault['type'],
                            'value': var_fault['value']
                        }

    def _get_name_by_vr(self, vr):
        for name, value_ref in self.value_references.items():
            if value_ref == vr:
                return name
        return None