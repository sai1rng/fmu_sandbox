import json
from pathlib import Path
import importlib.resources
import traceback

from fmpy import read_model_description, extract
from fmpy.fmi2 import FMU2Slave as FMPY_FMU2Slave

from pythonfmu.fmi2slave import Fmi2Slave, Fmi2Causality, Fmi2Variability, Fmi2Initial
from pythonfmu.variables import Real, Integer, Boolean, String

# Map FMPy model types to pythonfmu variable classes
FMPY_TO_PYTHONFMU_VAR_TYPE = {
    "Real": Real,
    "Integer": Integer,
    "Boolean": Boolean,
    "String": String,
}


class FMUWrapper(Fmi2Slave):
    """
    Wrapper FMU that embeds an original FMU and injects faults.
    This version implements explicit set/get handlers so that
    the pythonfmu C glue does not encounter uncaught Python exceptions.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.current_time = 0.0
        self.active_faults = {}
        self.original_fmu_instance = None
        self.original_fmu_unzip_dir = None

        # name -> innerFMU valueReference (from original modelDescription)
        self.value_references = {}

        # ----------------------------
        # 1) locate resources
        # ----------------------------
        try:
            resources_path = importlib.resources.files(self.__class__.__module__)
        except (AttributeError, TypeError):
            resources_path = Path(kwargs.get("resources", "."))

        original_fmu_path = resources_path / "Amplifier.fmu"
        config_path = resources_path / "fault_config.json"

        # ----------------------------
        # 2) load fault configuration
        # ----------------------------
        with open(config_path, "r") as f:
            self.fault_config = json.load(f)

        # ----------------------------
        # 3) mirror original FMU interface
        # ----------------------------
        self.model_description = read_model_description(original_fmu_path)

        self.modelName = f"{self.model_description.modelName}_FaultWrapper"
        self.author = "Wrapper generated by FMU Fault Injection Framework"
        self.description = f"Wraps '{self.model_description.modelName}' to inject faults."

        for var in self.model_description.modelVariables:
            var_type_cls = FMPY_TO_PYTHONFMU_VAR_TYPE.get(var.type, Real)
            self.register_variable(
                var_type_cls(
                    name=var.name,
                    causality=Fmi2Causality[var.causality],
                    variability=Fmi2Variability[var.variability],
                    initial=Fmi2Initial[var.initial] if var.initial else Fmi2Initial.undefined,
                    start=var.start,
                )
            )
            # valueReference here is the inner/original FMU VR (we'll use it when talking to the inner FMU)
            self.value_references[var.name] = var.valueReference

            # set default start values safely
            start_value = var.start
            if start_value is None:
                if var.type == "Real":
                    start_value = 0.0
                elif var.type == "Integer":
                    start_value = 0
                elif var.type == "Boolean":
                    start_value = False
                elif var.type == "String":
                    start_value = ""
            setattr(self, var.name, start_value)

        # ----------------------------
        # 4) prepare internal FMU
        # ----------------------------
        self.original_fmu_unzip_dir = extract(original_fmu_path)
        self.original_fmu_instance = FMPY_FMU2Slave(
            guid=self.model_description.guid,
            unzipDirectory=self.original_fmu_unzip_dir,
            modelIdentifier=self.model_description.coSimulation.modelIdentifier,
            instanceName="wrapped_instance",
            fmiCallLogger=None,
        )

    # ----------------------
    # FMI lifecycle methods
    # ----------------------
    def setup_experiment(self, start_time, stop_time=None, tolerance=None):
        self.current_time = start_time
        self.original_fmu_instance.setupExperiment(
            startTime=start_time, stopTime=stop_time, tolerance=tolerance
        )

    def enter_initialization_mode(self):
        self.original_fmu_instance.enterInitializationMode()

    def exit_initialization_mode(self):
        # copy fixed/parameter values from wrapper state -> inner FMU (typed)
        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.parameter or var.variability == Fmi2Variability.fixed:
                value = getattr(self, name)
                vr = self.value_references[name]
                vtype = var.type.__name__
                print(f"[exit_initialization_mode] Setting {name} (vr={vr}, type={vtype}) = {value}")
                if vtype == "Real":
                    self.original_fmu_instance.setReal([vr], [float(value)])
                elif vtype == "Integer":
                    self.original_fmu_instance.setInteger([vr], [int(value)])
                elif vtype == "Boolean":
                    self.original_fmu_instance.setBoolean([vr], [bool(value)])
                elif vtype == "String":
                    self.original_fmu_instance.setString([vr], [str(value)])

        self.original_fmu_instance.exitInitializationMode()

    def do_step(self, current_time, step_size):
        self.current_time = current_time
        self._update_active_faults()

        # Push inputs (wrapper -> inner) using typed _set_value (this applies faults here)
        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.input:
                self._set_value(name, getattr(self, name))

        # Advance the inner FMU
        self.original_fmu_instance.doStep(
            currentCommunicationPoint=current_time,
            communicationStepSize=step_size,
            noSetFMUStatePriorToCurrentPoint=True,
        )

        # Pull outputs from inner FMU -> wrapper attributes
        for name, var in self.vars.items():
            if var.causality == Fmi2Causality.output:
                got = self._get_value(name)
                if got is not None:
                    # fmpy get* returns a list, take first item
                    setattr(self, name, got[0] if isinstance(got, (list, tuple)) else got)

        return True

    def reset(self):
        self.original_fmu_instance.reset()

    def terminate(self):
        self.original_fmu_instance.terminate()
        self.original_fmu_instance.freeInstance()

    # ----------------------
    # typed access to inner FMU
    # ----------------------
    def _get_value(self, var_name):
        vr = self.value_references[var_name]
        var_type = self.vars[var_name].type.__name__
        if var_type == "Real":
            return self.original_fmu_instance.getReal([vr])
        elif var_type == "Integer":
            return self.original_fmu_instance.getInteger([vr])
        elif var_type == "Boolean":
            return self.original_fmu_instance.getBoolean([vr])
        elif var_type == "String":
            return self.original_fmu_instance.getString([vr])
        return None

    def _set_value(self, var_name, value):
        """Set value on the *inner* FMU (called from do_step), applying faults."""
        vr = self.value_references[var_name]
        var_type = self.vars[var_name].type.__name__
        modified_value = value

        if vr in self.active_faults:
            fault = self.active_faults[vr]
            fault_type = fault["type"]
            if fault_type == "stuckAtValue":
                modified_value = fault["value"]
            elif fault_type == "offset":
                modified_value = value + fault["value"]
            if modified_value != value:
                print(f"--- FAULT INJECTED at t={self.current_time:.2f}s on '{var_name}' (vr={vr}) ---")
                print(f"  Original: {value}, Faulty: {modified_value} (Type: {fault_type})")

        print(f"[_set_value] innerFMU set {var_name} (vr={vr}, type={var_type}) = {modified_value}")

        if var_type == "Real":
            self.original_fmu_instance.setReal([vr], [float(modified_value)])
        elif var_type == "Integer":
            self.original_fmu_instance.setInteger([vr], [int(modified_value)])
        elif var_type == "Boolean":
            self.original_fmu_instance.setBoolean([vr], [bool(modified_value)])
        elif var_type == "String":
            self.original_fmu_instance.setString([vr], [str(modified_value)])

    # ----------------------
    # Fault schedule
    # ----------------------
    def _update_active_faults(self):
        self.active_faults = {}
        for event in self.fault_config.get("events", []):
            start = event.get("startTime", 0.0)
            duration = event.get("duration", float("inf"))
            end = start + duration
            if start <= self.current_time < end:
                for vf in event.get("variables", []):
                    vr = vf.get("valueReference")
                    if vr is not None:
                        self.active_faults[vr] = {"type": vf["type"], "value": vf["value"]}

    def _get_name_by_vr(self, vr):
        # value_references maps name -> inner VR; convert vr to int and search
        try:
            ival = int(vr)
        except Exception:
            ival = vr
        for name, value_ref in self.value_references.items():
            if int(value_ref) == int(ival):
                return name
        return None

    # ----------------------
    # Explicit handlers called by the pythonfmu C glue
    # ----------------------
    def setReal(self, *args):
        """
        Accept either (vrs, values) or (vrs, nvr, values) depending on glue.
        Sets wrapper attributes only (do NOT forward to inner FMU here).
        """
        try:
            if len(args) == 2:
                vrs, values = args
            elif len(args) == 3:
                vrs, _nvr, values = args
            else:
                raise TypeError("Unexpected setReal signature")

            for i, vr in enumerate(vrs):
                try:
                    name = self._get_name_by_vr(vr)
                    if name is None:
                        print(f"[setReal] Unknown VR {vr} (skipping)")
                        continue
                    val = float(values[i])
                    setattr(self, name, val)
                    # debug
                    print(f"[setReal] wrapper attr set {name} (vr={vr}) = {val}")
                except Exception:
                    traceback.print_exc()
                    print(f"[setReal] failed to set VR {vr} -> skipping (no exception raised to glue)")
            # don't raise
        except Exception:
            traceback.print_exc()
            # swallow: do not propagate to C glue (which would return fatal)

    def setInteger(self, *args):
        try:
            if len(args) == 2:
                vrs, values = args
            elif len(args) == 3:
                vrs, _nvr, values = args
            else:
                raise TypeError("Unexpected setInteger signature")

            for i, vr in enumerate(vrs):
                try:
                    name = self._get_name_by_vr(vr)
                    if name is None:
                        print(f"[setInteger] Unknown VR {vr} (skipping)")
                        continue
                    val = int(values[i])
                    setattr(self, name, val)
                    print(f"[setInteger] wrapper attr set {name} (vr={vr}) = {val}")
                except Exception:
                    traceback.print_exc()
        except Exception:
            traceback.print_exc()

    def setBoolean(self, *args):
        try:
            if len(args) == 2:
                vrs, values = args
            elif len(args) == 3:
                vrs, _nvr, values = args
            else:
                raise TypeError("Unexpected setBoolean signature")

            for i, vr in enumerate(vrs):
                try:
                    name = self._get_name_by_vr(vr)
                    if name is None:
                        print(f"[setBoolean] Unknown VR {vr} (skipping)")
                        continue
                    val = bool(values[i])
                    setattr(self, name, val)
                    print(f"[setBoolean] wrapper attr set {name} (vr={vr}) = {val}")
                except Exception:
                    traceback.print_exc()
        except Exception:
            traceback.print_exc()

    def setString(self, *args):
        try:
            if len(args) == 2:
                vrs, values = args
            elif len(args) == 3:
                vrs, _nvr, values = args
            else:
                raise TypeError("Unexpected setString signature")

            for i, vr in enumerate(vrs):
                try:
                    name = self._get_name_by_vr(vr)
                    if name is None:
                        print(f"[setString] Unknown VR {vr} (skipping)")
                        continue
                    val = str(values[i])
                    setattr(self, name, val)
                    print(f"[setString] wrapper attr set {name} (vr={vr}) = {val}")
                except Exception:
                    traceback.print_exc()
        except Exception:
            traceback.print_exc()

    # getters: return lists of values for the requested VRs
    def getReal(self, *args):
        try:
            vrs = args[0]
            out = []
            for vr in vrs:
                name = self._get_name_by_vr(vr)
                if name is None:
                    out.append(0.0)
                else:
                    out.append(float(getattr(self, name, 0.0)))
            print(f"[getReal] returning {out} for vrs {list(vrs)}")
            return out
        except Exception:
            traceback.print_exc()
            return []

    def getInteger(self, *args):
        try:
            vrs = args[0]
            out = []
            for vr in vrs:
                name = self._get_name_by_vr(vr)
                if name is None:
                    out.append(0)
                else:
                    out.append(int(getattr(self, name, 0)))
            print(f"[getInteger] returning {out}")
            return out
        except Exception:
            traceback.print_exc()
            return []

    def getBoolean(self, *args):
        try:
            vrs = args[0]
            out = []
            for vr in vrs:
                name = self._get_name_by_vr(vr)
                if name is None:
                    out.append(False)
                else:
                    out.append(bool(getattr(self, name, False)))
            print(f"[getBoolean] returning {out}")
            return out
        except Exception:
            traceback.print_exc()
            return []

    def getString(self, *args):
        try:
            vrs = args[0]
            out = []
            for vr in vrs:
                name = self._get_name_by_vr(vr)
                if name is None:
                    out.append("")
                else:
                    out.append(str(getattr(self, name, "")))
            print(f"[getString] returning {out}")
            return out
        except Exception:
            traceback.print_exc()
            return []
